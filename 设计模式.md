# 《设计模式》



## 一、原则介绍

### 单一职责原则

单一职责原则：应该有且仅有一个原因引起类的变更（一个责任）。

接口一定要做到单一原则，类的设计尽量做到只有一个原因引起变化。

### 里氏替换原则

所有引用基类的地方必须能透明地使用其子类的对象。（只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类，但是反过来就不行了，有子类出现的地方，父类未必就能适应）



如果子类不能完整地实现父类的方法， 或者父类的某些方法在子类中已经发生“畸变”， 则建议断开父子继承关系， 采用依赖、 聚集、 组合等关系代替继承。



子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松



覆写或实现父类的方法时，输出结果可以被缩小（小于等于父类）



采用里氏替换原则的目的是增强程序的健壮性



### 依赖倒置原则



定义：

- 高层模块不应该依赖底层模块，两者都应该依赖其抽象
- 抽象不应该依赖细节
- 细节应该依赖抽象



采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。



对象的依赖关系有三种方式来传递：

- 构造函数传递依赖对象
-  setter方法传递依赖对象
- 接口声明依赖对象



依赖倒置原则的本质：通过抽象使各个类或模块的实现彼此独立。需遵循以下几个规则：

- 每个类尽量都有接口或抽象类
- 变量的表面类型尽量是接口或者抽象类
- **任何类后不应该从具体类派生**
- 尽量不要覆写基类的方法
- 结合里氏替换原则使用
  - 接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的是实现



### 接口隔离原则

建立单一接口，不要建立臃肿庞大的接口------接口尽量细化，同时接口中的方法尽量少。



根据接口隔离原则拆分接口时，首先必须满足单一职责原则。



接口要高内聚（提高接口、类、模块的处理能力，减少对外的交互）



### 迪米特法则



1. 只与朋友类交流（出现在成员变量、方法的输入输出参数中的类称为成员朋友类）
   1. 一个类只和朋友交流，不与陌生类交流。类与类之间的关系是建立在类间的，不是方法间，因此一个方法尽量不引入一个类中不存在的对象。
2. 朋友间也是有距离的。
   1. 在设计时需要反复衡量：是否还可以再减少public方法和属性，是否可以修改为private、等访问权限。
   2. 尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛。
3. 是自己的就是自己的
   1. 如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。



### 开闭原则

一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

开闭原则可以提高复用性。

	1. 抽象约束
	2. 元数据控制模块行为
		1. 元数据：用来描述环境和数据的数据，即：配置参数，参数可以从文件中获得，也可以从数据库中获得。
	3. 封装变化：
		1. 将相同的变化封装到一个接口或抽象类中
		2. 将不同的变化封装到不同的接口或抽象类中





## 二、23种设计模式



### 单例模式

确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。



```python
class Singleton:
    _instance = None
    
    def __new__(cls):
        if not cls._instance:
            cls._instance = super().__new__(cls)
        return cls._instance
```

单例模式的使用场景：

- 要求生成唯一序列号的环境
- 在整个项目中需要一个共享访问点或共享数据
- 创建一个对象需要消耗的资源过多
- 需要定义大量的静态常量和静态方法的环境

单例模式需要注意，在高并发的情况下可能在内存中出现多个实例的情况。



单例模式的扩展——有上限的多例模式





### 工厂方法模式

定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其他子类。

![image-20230526100502363](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230526100502363.png)

工厂方法模式降低模块间的耦合，屏蔽产品类。是典型的解耦框架。

扩展：

- 简单工厂模式（静态工厂模式）取消Creator抽象类，将工厂方法设置为静态类型，以此简化类的创建过程。
- 在复杂的应用中一般采用多工厂的方法，然后再增加一个协调类，避免调用者与各个子工厂交流，协调类的作用是封装子工厂类，对高层模块提供统一的访问接口
- 替代单例模式
  - 实现单例的方式：通过获得类构造器， 然后设置访问权限， 生成一个对象， 然后提供外部访问， 保证内存中的对象唯一。 
- 延迟初始化（对象被消费完毕，并不立即释放，保持其初始状态，等待再次被使用），也可以用于限制最大实例化数量。



### 抽象工厂模式

为创建一组相关或相互依赖的对象提供一个接口， 而且无须指定它们的具体类。

![image-20230526110248157](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230526110248157.png)

*有N个产品族，在抽象工厂类中就应该有N个创建方法*

产品族内的约束为非公开状态。

产品族扩展困难。

使用场景：一个对象族都有相同的约束，则可以使用抽象工厂模式。

注意事项：该模式下，横向扩展容易，纵向扩展困难。



### 模板方法模式



**在软件开发中，如果相同的一段代码复制过两次，就需要对设计产生怀疑。**



定义一个操作中的算法框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。



抽象模板中的基本方法尽量设计为protected类型，符合迪米特法则，不需要暴露的属性和方法尽量不要设置为protected类型。



钩子方法：其返回值可以影响模板方法的执行结果。



模板方法模式可以在子类重写了父类的部分方法后，再调用从父类继承的方法，以此产生不同的效果。



### 建造者模式

![image-20230526145813176](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230526145813176.png)



**如果将List或map定义为类的成员变量，那么在方法中的调用一定要做一个clear的动作，以防数据混乱。**



定义：将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。



使用场景：

- 相同的方法， 不同的执行顺序， 产生不同的事件结果时， 可以采用建造者模式。
- 多个部件或零件， 都可以装配到一个对象中， 但是产生的运行结果又不相同时， 则可以使用该模式
- 产品类非常复杂， 或者产品类中的调用顺序不同产生了不同的效能， 这个时候使用建造者模式非常合适。
- 在对象创建过程中会使用到系统中的一些其他对象， 这些对象在产品对象的创建过程中不易得到时， 也可以采用建造者模式封装该对象的创建过程。 该种场景只能是一个补偿方法， 因为一个对象不容易获得， 而在设计阶段竟然没有发觉， 而要通过创建者模式柔化创建过程， 本身已经违反设计的最初目标。



**建造者模式关注的是零件类型和装配工艺（顺序）**



### 代理模式*

定义：为其他对象提供一种代理以控制对这个对象的访问。



![image-20230528115324358](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230528115324358.png)

一个代理类可以代理多个被委托者或被代理者， 因此一个代理类具体代理哪个真实主题角色， 是由场景类决定的。 当然， 最简单的情况就是一个主题类和一个代理类， 这是最简洁的代理模式。 在通常情况下， 一个接口只需要一个代理类就可以了， 具体代理哪个实现类由高层模块来决定， 也就是在代理类的构造函数中传递被代理者，



普通代理：调用者只知代理而不知道真实的角色，屏蔽真实角色的变更对高层模块的影响

强制代理：从真实角色查找到代理角色，不允许直接访问真实角色。高层模块只有调用getProxy才可以访问真实角色的所有方法。

动态代理：在实现阶段不用关心代理谁，而在运行阶段才指定代理哪一个对象。（主要意图是解决“审计问题”？）

![image-20230529092539618](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230529092539781.png)

通过InvocationHandler接口， 所有方法都由该Handler来进行处理， 即所有被代理的方法都由InvocationHandler接管实际的处理任务。



### 原型模式

定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

![image-20230529094853936](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230529094853936.png)

优点：

- 性能优良：在内存二进制流的拷贝，比直接new一个对象性能好很多。
- 逃避构造函数的约束：直接在内存中拷贝，构造函数是不会执行的。

注意事项：

​	-	构造函数不会被执行

覆写的clone（）函数是浅拷贝，需要手动编写深拷贝（同时拷贝其变量）。

**深拷贝和浅拷贝不要混合使用，特别是在涉及类的继承时，父类有多个引用的情况就非常复杂，建议将深拷贝和浅拷贝分开实现	**

**要使用clone方法，类的成员变量上不要增加final关键字**



### 中介者模式

定义：用一个中介对象封装一系列的对象交互， 中介者使各对象不需要显示地相互作用， 从而使其耦合松散， 而且可以独立地改变它们之间的交互。 

在多个对象依赖的情况下，通过加入中介者角色，取消了多个对象的关联或依赖关系，减少对象的耦合性。

![image-20230529102418263](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230529102418263.png)

- Mediator抽象中介者角色

  定义统一的接口，用于各同事角色之间的通信

- Concrete Mediator具体中介者角色

  协调各同事角色实现协作行为

- Colleague

  通过中介者角色协作



中介者模式适用于多个对象之间紧密耦合的情况，紧密耦合的标准是：在类图中出现蜘蛛网状结构。



### 命令模式

![image-20230529145625903](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230529145625903.png)

定义：将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。





### 责任链模式

定义：使多个对象都有机会处理请求， 从而避免了请求的发送者和接受者之间的耦合关系。 将这些对象连成一条链， 并沿着这条链传递该请求， 直到有对象处理它为止。

![image-20230529153411018](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230529153411018.png)

抽象的处理者实现三个职责：

- 定义一个请求的处理方法handleMessage，唯一对外开放的方法；
- 定义一个链的编排方法setNext，设置下一个处理者
- 定义具体的请求者必须实现的两个方法：
  - 定义自己能够处理的级别getHandleLevel和具体的处理任务echo



注意事项：需要控制链中节点的数量，避免出现超长链的情况。每个请求都是从链头遍历到链尾，当链比较长的时候，性能是一个非常大的问题。



### 装饰模式

定义：动态地给一个对象添加一些额外的职责。就增加功能来说， 装饰模式相比生成子类更为灵活。

![image-20230529171555934](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230529171555934.png)



### 策略模式

定义：定义一组算法， 将每个算法都封装起来， 并且使它们之间可以互换。  

![image-20230529172412498](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230529172412498.png)

- Context封装对象
  - 屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化


# 创建类模式选择


>创建类模式包括工厂方法模式、建造者模式、抽象工厂模式、单例模式和原型模式，他们都能够提供对象的创建和管理职责

#### 工厂方法模式与建造者模式对比

>工厂方法模式注重的是整体对象的创建方法，而建造者模式注重的是部件构建的过程。

从工厂方法模式中得到的是一个整体对象，它们之间具有相似的功能和架构。但是在建造者模式中需要配置对象的各个部件（建造者中定义对象，并通过相应的set方法配置其各个部件）。


>工厂方法模式的对象粒度比较粗，建造者模式的产品对象粒度比较细。

#### 抽象工厂模式与建造者模式对比


> 抽象工厂模式认为对象是完整的，不可拆分的。

> 如果希望屏蔽对象的创建过程，只提供一个封装良好的对象，则可以选择抽象工厂模式；而建造者模式可以在构件的装配方面，可以产生一个非常灵活的架构，方便地扩展和维护系统。


# 结构类模式对比
**结构类是指它们都是通过组合类或对象产生更大结构以适应更高层次的逻辑需求**。结构类模式包括适配器模式、 桥梁模式、 组合模式、 装饰模式、 门面模式、 享元模式和代理模式。

#### 代理模式与装饰模式对比

> 代理模式着重对代理过程的控制， 而装饰模式则是对类的功能进行加强或减弱， 它着重类的功能变化

结构上都是对对象接口的继承和丰富，然后供用户调用。但是按照功能，代理模式是用于控制对象，对其有控制权，而装饰模式只是对对象的装饰丰富功能。


#### 装饰模式与适配器模式对比

> 装饰模式包装的是自己的兄弟类， 隶属于同一个家族（相同接口或父类） ， 适配器模式则修饰非血缘关系类， 把一个非本家族的对象伪装成本家族的对象， 注意是伪装， 因此它的本质还是非相同接口的对象。

采用适配器模式，是将两个没有血缘关系的类建立联系，通过伪装的方式，实现不同物种的相同处理过程。

两种模式的意图是不同的。装饰模式意在强化对象的某个功能，而适配器模式意在强调其在两个非血缘关系类之间的转化。


**使用场景不同**
>装饰模式在任何时候都可以使用，只要是想增强类的功能，而适配器模式则是补救模式，一般出现在系统成熟或已经构建完毕的项目中，作为一个紧急处理手段采用。

装饰器的扩展性比较好，但是适配器模式则比较困难。


# 行为类模式

> 行为类模式包括责任链模式、 命令模式、 解释器模式、 迭代器模式、 中介者模式、 备忘录模式、 观察者模式、 状态模式、 策略模式、 模板方法模式、 访问者模式。

#### 命令模式与策略模式对比

> 策略模式的意图是封装算法，让这些算法独立并可以相互替换。而命令模式则是对动作的解耦，将一个动作的执行分为执行对象，执行行为，让两者相互独立而不相互影响。


>策略类关注的是算法替换的问题，命令模式则关注的是解耦问题。


#### 策略模式与状态模式对比

> 策略模式封装的是不同的算法，算法之间没有交互，以达到算法可以自由切换的目的；而状态模式封装的是不同的状态，以达到状态切换行为随之发生改变的目的‘。

状态模式中，在该状态下可以对状态进行切换，为进入下一个状态做准备。

#### 观察者模式与责任链模式对比

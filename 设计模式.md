# 《设计模式》



## 一、原则介绍

### 单一职责原则

单一职责原则：应该有且仅有一个原因引起类的变更（一个责任）。

接口一定要做到单一原则，类的设计尽量做到只有一个原因引起变化。

### 里氏替换原则

所有引用基类的地方必须能透明地使用其子类的对象。（只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类，但是反过来就不行了，有子类出现的地方，父类未必就能适应）



如果子类不能完整地实现父类的方法， 或者父类的某些方法在子类中已经发生“畸变”， 则建议断开父子继承关系， 采用依赖、 聚集、 组合等关系代替继承。



子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松



覆写或实现父类的方法时，输出结果可以被缩小（小于等于父类）



采用里氏替换原则的目的是增强程序的健壮性



### 依赖倒置原则



定义：

- 高层模块不应该依赖底层模块，两者都应该依赖其抽象
- 抽象不应该依赖细节
- 细节应该依赖抽象



采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。



对象的依赖关系有三种方式来传递：

- 构造函数传递依赖对象
-  setter方法传递依赖对象
- 接口声明依赖对象



依赖倒置原则的本质：通过抽象使各个类或模块的实现彼此独立。需遵循以下几个规则：

- 每个类尽量都有接口或抽象类
- 变量的表面类型尽量是接口或者抽象类
- **任何类后不应该从具体类派生**
- 尽量不要覆写基类的方法
- 结合里氏替换原则使用
  - 接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的是实现



### 接口隔离原则

建立单一接口，不要建立臃肿庞大的接口------接口尽量细化，同时接口中的方法尽量少。



根据接口隔离原则拆分接口时，首先必须满足单一职责原则。



接口要高内聚（提高接口、类、模块的处理能力，减少对外的交互）



### 迪米特法则



1. 只与朋友类交流（出现在成员变量、方法的输入输出参数中的类称为成员朋友类）
   1. 一个类只和朋友交流，不与陌生类交流。类与类之间的关系是建立在类间的，不是方法间，因此一个方法尽量不引入一个类中不存在的对象。
2. 朋友间也是有距离的。
   1. 在设计时需要反复衡量：是否还可以再减少public方法和属性，是否可以修改为private、等访问权限。
   2. 尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛。
3. 是自己的就是自己的
   1. 如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。



### 开闭原则

一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

开闭原则可以提高复用性。

	1. 抽象约束
	2. 元数据控制模块行为
		1. 元数据：用来描述环境和数据的数据，即：配置参数，参数可以从文件中获得，也可以从数据库中获得。
	3. 封装变化：
		1. 将相同的变化封装到一个接口或抽象类中
		2. 将不同的变化封装到不同的接口或抽象类中





## 二、23种设计模式



### 单例模式

确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。



```python
class Singleton:
    _instance = None
    
    def __new__(cls):
        if not cls._instance:
            cls._instance = super().__new__(cls)
        return cls._instance
```

单例模式的使用场景：

- 要求生成唯一序列号的环境
- 在整个项目中需要一个共享访问点或共享数据
- 创建一个对象需要消耗的资源过多
- 需要定义大量的静态常量和静态方法的环境

单例模式需要注意，在高并发的情况下可能在内存中出现多个实例的情况。



单例模式的扩展——有上限的多例模式





### 工厂方法模式

定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其他子类。

![image-20230526100502363](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230526100502363.png)

工厂方法模式降低模块间的耦合，屏蔽产品类。是典型的解耦框架。

扩展：

- 简单工厂模式（静态工厂模式）取消Creator抽象类，将工厂方法设置为静态类型，以此简化类的创建过程。
- 在复杂的应用中一般采用多工厂的方法，然后再增加一个协调类，避免调用者与各个子工厂交流，协调类的作用是封装子工厂类，对高层模块提供统一的访问接口
- 替代单例模式
  - 实现单例的方式：通过获得类构造器， 然后设置访问权限， 生成一个对象， 然后提供外部访问， 保证内存中的对象唯一。 
- 延迟初始化（对象被消费完毕，并不立即释放，保持其初始状态，等待再次被使用），也可以用于限制最大实例化数量。



### 抽象工厂模式

为创建一组相关或相互依赖的对象提供一个接口， 而且无须指定它们的具体类。

![image-20230526110248157](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230526110248157.png)

*有N个产品族，在抽象工厂类中就应该有N个创建方法*

产品族内的约束为非公开状态。

产品族扩展困难。

使用场景：一个对象族都有相同的约束，则可以使用抽象工厂模式。

注意事项：该模式下，横向扩展容易，纵向扩展困难。



### 模板方法模式



**在软件开发中，如果相同的一段代码复制过两次，就需要对设计产生怀疑。**



定义一个操作中的算法框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。



抽象模板中的基本方法尽量设计为protected类型，符合迪米特法则，不需要暴露的属性和方法尽量不要设置为protected类型。



钩子方法：其返回值可以影响模板方法的执行结果。



模板方法模式可以在子类重写了父类的部分方法后，再调用从父类继承的方法，以此产生不同的效果。



### 建造者模式

![image-20230526145813176](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230526145813176.png)



**如果将List或map定义为类的成员变量，那么在方法中的调用一定要做一个clear的动作，以防数据混乱。**



定义：将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。



使用场景：

- 相同的方法， 不同的执行顺序， 产生不同的事件结果时， 可以采用建造者模式。
- 多个部件或零件， 都可以装配到一个对象中， 但是产生的运行结果又不相同时， 则可以使用该模式
- 产品类非常复杂， 或者产品类中的调用顺序不同产生了不同的效能， 这个时候使用建造者模式非常合适。
- 在对象创建过程中会使用到系统中的一些其他对象， 这些对象在产品对象的创建过程中不易得到时， 也可以采用建造者模式封装该对象的创建过程。 该种场景只能是一个补偿方法， 因为一个对象不容易获得， 而在设计阶段竟然没有发觉， 而要通过创建者模式柔化创建过程， 本身已经违反设计的最初目标。



**建造者模式关注的是零件类型和装配工艺（顺序）**




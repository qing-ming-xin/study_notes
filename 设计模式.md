# 《设计模式》



## 一、原则介绍

### 单一职责原则

单一职责原则：应该有且仅有一个原因引起类的变更（一个责任）。

接口一定要做到单一原则，类的设计尽量做到只有一个原因引起变化。

### 里氏替换原则

所有引用基类的地方必须能透明地使用其子类的对象。（只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类，但是反过来就不行了，有子类出现的地方，父类未必就能适应）



如果子类不能完整地实现父类的方法， 或者父类的某些方法在子类中已经发生“畸变”， 则建议断开父子继承关系， 采用依赖、 聚集、 组合等关系代替继承。



子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松



覆写或实现父类的方法时，输出结果可以被缩小（小于等于父类）



采用里氏替换原则的目的是增强程序的健壮性



### 依赖倒置原则



定义：

- 高层模块不应该依赖底层模块，两者都应该依赖其抽象
- 抽象不应该依赖细节
- 细节应该依赖抽象



采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。



对象的依赖关系有三种方式来传递：

- 构造函数传递依赖对象
-  setter方法传递依赖对象
- 接口声明依赖对象



依赖倒置原则的本质：通过抽象使各个类或模块的实现彼此独立。需遵循以下几个规则：

- 每个类尽量都有接口或抽象类
- 变量的表面类型尽量是接口或者抽象类
- **任何类后不应该从具体类派生**
- 尽量不要覆写基类的方法
- 结合里氏替换原则使用
  - 接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的是实现



### 接口隔离原则

建立单一接口，不要建立臃肿庞大的接口------接口尽量细化，同时接口中的方法尽量少。



根据接口隔离原则拆分接口时，首先必须满足单一职责原则。



接口要高内聚（提高接口、类、模块的处理能力，减少对外的交互）



### 迪米特法则



1. 只与朋友类交流（出现在成员变量、方法的输入输出参数中的类称为成员朋友类）
   1. 一个类只和朋友交流，不与陌生类交流。类与类之间的关系是建立在类间的，不是方法间，因此一个方法尽量不引入一个类中不存在的对象。
2. 朋友间也是有距离的。
   1. 在设计时需要反复衡量：是否还可以再减少public方法和属性，是否可以修改为private、等访问权限。
   2. 尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛。
3. 是自己的就是自己的
   1. 如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。



### 开闭原则

一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

开闭原则可以提高复用性。

	1. 抽象约束
	2. 元数据控制模块行为
		1. 元数据：用来描述环境和数据的数据，即：配置参数，参数可以从文件中获得，也可以从数据库中获得。
	3. 封装变化：
		1. 将相同的变化封装到一个接口或抽象类中
		2. 将不同的变化封装到不同的接口或抽象类中





## 二、23种设计模式



### 单例模式

确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。



```python
class Singleton:
    _instance = None
    
    def __new__(cls):
        if not cls._instance:
            cls._instance = super().__new__(cls)
        return cls._instance
```

单例模式的使用场景：

- 要求生成唯一序列号的环境
- 在整个项目中需要一个共享访问点或共享数据
- 创建一个对象需要消耗的资源过多
- 需要定义大量的静态常量和静态方法的环境

单例模式需要注意，在高并发的情况下可能在内存中出现多个实例的情况。



单例模式的扩展——有上限的多例模式





### 工厂方法模式

定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其他子类。

![image-20230526100502363](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230526100502363.png)

工厂方法模式降低模块间的耦合，屏蔽产品类。是典型的解耦框架。

扩展：

- 简单工厂模式（静态工厂模式）取消Creator抽象类，将工厂方法设置为静态类型，以此简化类的创建过程。
- 在复杂的应用中一般采用多工厂的方法，然后再增加一个协调类，避免调用者与各个子工厂交流，协调类的作用是封装子工厂类，对高层模块提供统一的访问接口
- 替代单例模式
  - 实现单例的方式：通过获得类构造器， 然后设置访问权限， 生成一个对象， 然后提供外部访问， 保证内存中的对象唯一。 
- 延迟初始化（对象被消费完毕，并不立即释放，保持其初始状态，等待再次被使用），也可以用于限制最大实例化数量。



### 抽象工厂模式

为创建一组相关或相互依赖的对象提供一个接口， 而且无须指定它们的具体类。

![image-20230526110248157](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230526110248157.png)

*有N个产品族，在抽象工厂类中就应该有N个创建方法*

产品族内的约束为非公开状态。

产品族扩展困难。

使用场景：一个对象族都有相同的约束，则可以使用抽象工厂模式。

注意事项：该模式下，横向扩展容易，纵向扩展困难。



### 模板方法模式



**在软件开发中，如果相同的一段代码复制过两次，就需要对设计产生怀疑。**



定义一个操作中的算法框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。



抽象模板中的基本方法尽量设计为protected类型，符合迪米特法则，不需要暴露的属性和方法尽量不要设置为protected类型。



钩子方法：其返回值可以影响模板方法的执行结果。



模板方法模式可以在子类重写了父类的部分方法后，再调用从父类继承的方法，以此产生不同的效果。



### 建造者模式

![image-20230526145813176](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230526145813176.png)



**如果将List或map定义为类的成员变量，那么在方法中的调用一定要做一个clear的动作，以防数据混乱。**



定义：将一个复杂对象的构建与他的表示分离，使得同样的构建过程可以创建不同的表示。



使用场景：

- 相同的方法， 不同的执行顺序， 产生不同的事件结果时， 可以采用建造者模式。
- 多个部件或零件， 都可以装配到一个对象中， 但是产生的运行结果又不相同时， 则可以使用该模式
- 产品类非常复杂， 或者产品类中的调用顺序不同产生了不同的效能， 这个时候使用建造者模式非常合适。
- 在对象创建过程中会使用到系统中的一些其他对象， 这些对象在产品对象的创建过程中不易得到时， 也可以采用建造者模式封装该对象的创建过程。 该种场景只能是一个补偿方法， 因为一个对象不容易获得， 而在设计阶段竟然没有发觉， 而要通过创建者模式柔化创建过程， 本身已经违反设计的最初目标。



**建造者模式关注的是零件类型和装配工艺（顺序）**



### 代理模式*

定义：为其他对象提供一种代理以控制对这个对象的访问。



![image-20230528115324358](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230528115324358.png)

一个代理类可以代理多个被委托者或被代理者， 因此一个代理类具体代理哪个真实主题角色， 是由场景类决定的。 当然， 最简单的情况就是一个主题类和一个代理类， 这是最简洁的代理模式。 在通常情况下， 一个接口只需要一个代理类就可以了， 具体代理哪个实现类由高层模块来决定， 也就是在代理类的构造函数中传递被代理者，



普通代理：调用者只知代理而不知道真实的角色，屏蔽真实角色的变更对高层模块的影响

强制代理：从真实角色查找到代理角色，不允许直接访问真实角色。高层模块只有调用getProxy才可以访问真实角色的所有方法。

动态代理：在实现阶段不用关心代理谁，而在运行阶段才指定代理哪一个对象。（主要意图是解决“审计问题”？）

![image-20230529092539618](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230529092539781.png)

通过InvocationHandler接口， 所有方法都由该Handler来进行处理， 即所有被代理的方法都由InvocationHandler接管实际的处理任务。



### 原型模式

定义：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

![image-20230529094853936](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230529094853936.png)

优点：

- 性能优良：在内存二进制流的拷贝，比直接new一个对象性能好很多。
- 逃避构造函数的约束：直接在内存中拷贝，构造函数是不会执行的。

注意事项：

​	-	构造函数不会被执行

覆写的clone（）函数是浅拷贝，需要手动编写深拷贝（同时拷贝其变量）。

**深拷贝和浅拷贝不要混合使用，特别是在涉及类的继承时，父类有多个引用的情况就非常复杂，建议将深拷贝和浅拷贝分开实现	**

**要使用clone方法，类的成员变量上不要增加final关键字**



### 中介者模式

定义：用一个中介对象封装一系列的对象交互， 中介者使各对象不需要显示地相互作用， 从而使其耦合松散， 而且可以独立地改变它们之间的交互。 

在多个对象依赖的情况下，通过加入中介者角色，取消了多个对象的关联或依赖关系，减少对象的耦合性。

![image-20230529102418263](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230529102418263.png)

- Mediator抽象中介者角色

  定义统一的接口，用于各同事角色之间的通信

- Concrete Mediator具体中介者角色

  协调各同事角色实现协作行为

- Colleague

  通过中介者角色协作



中介者模式适用于多个对象之间紧密耦合的情况，紧密耦合的标准是：在类图中出现蜘蛛网状结构。



### 命令模式

![image-20230529145625903](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230529145625903.png)

定义：将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。





### 责任链模式

定义：使多个对象都有机会处理请求， 从而避免了请求的发送者和接受者之间的耦合关系。 将这些对象连成一条链， 并沿着这条链传递该请求， 直到有对象处理它为止。

![image-20230529153411018](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230529153411018.png)

抽象的处理者实现三个职责：

- 定义一个请求的处理方法handleMessage，唯一对外开放的方法；
- 定义一个链的编排方法setNext，设置下一个处理者
- 定义具体的请求者必须实现的两个方法：
  - 定义自己能够处理的级别getHandleLevel和具体的处理任务echo



注意事项：需要控制链中节点的数量，避免出现超长链的情况。每个请求都是从链头遍历到链尾，当链比较长的时候，性能是一个非常大的问题。



### 装饰模式

定义：动态地给一个对象添加一些额外的职责。就增加功能来说， 装饰模式相比生成子类更为灵活。

![image-20230529171555934](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230529171555934.png)



### 策略模式

定义：定义一组算法， 将每个算法都封装起来， 并且使它们之间可以互换。  

![image-20230529172412498](https://cdn.jsdelivr.net/gh/qing-ming-xin/picb/image-20230529172412498.png)

- Context封装对象
  - 屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化


# C++学习笔记

*清空杯子，重新注入*

## 1. 《C++ Primer Plus（第6版）》读书笔记



*通常把原型放到main()定义之前，将源代码放在main()的后面。（函数原型==函数声明）*



main()函数的返回值并不是返回给程序的其他部分，而是返回给操作系统。



当前通行的理念是，只让需要访问名称控件std的函数访问它是更好的选择。



变量名命名规则：

- 在名称中只能使用字母字符、数字和下划线(_)
- 名称的第一个字符不能是数字
- 区分大写字符和小写字符
- 不能将C++关键字用作名称
- 以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的名称被保留给实现，用作全局标识符
- C++对于名称的长度没有限制，名称中所有的字符都有意义，但有些平台有长度限制



*cout以不同进制显示：cout还提供了控制符dec、hex和oct分别用于指示 cout 以十进制、十六进制和八进制格式显示整数。*



*C++中对字符用单引号，对字符串使用双引号*



*8位char可以表示基本字符集，另一种类型wchar_t(宽字符类型)可以表示扩展字符集。wchar_t是一种整数类型，它有足够的空间，可以表示系统使用的最大扩展字符集。wcin和wcout用于处理wchar_t流。*



*常量(const)被初始化后，其值就被固定了，编译器被不允许再修改该常量的值*



***const 与 #define对比：***

- const可以明确指定类型
- 可以使用C++的作用域规则将定义限制在特定的函数或文件中
- 可以将const用于更负责的类型





*cout可以调用setf()成员函数来修改结果的显示方式*：

```c++
cout.setf(ios_base::fixed, ios_base::floatfield);
```



***auto只能用于单值初始化，而不能用于初始化列表***



C++11中的auto声明，让编译器能够根据初始值的类型推断变量的类型。



cin读取时，会将回车键生成的换行符留在输入队列中



C++允许在声明结构变量时省略关键字struct



C++允许指定占用特定位数的结构成员，字段的类型应为整型或枚举，接下来是冒号，冒号后边是数字，它指定了使用的位数。



共用体(union)， 它能够存储不同的数据类型，但只能同时存储其中的一种类型。其的用途之一是，当数据项使用两种或更多种格式时，可节省空间。



枚举(enum)没有被初始化的枚举量的值比其前面的枚举量大1，**枚举量的值必须是整数**。



**一定要在对指针应用解除引用运算符(\*)之前，将指针初始化为一个确定的、适当的地址。**

```c++
//错误示范
long* fellow;
*fellow = 223323;
```



**只能用delete来释放使用new分配的内存。然而，对空指针使用delete是安全的**



***将指针变量加1后，其增加的值等于指向的类型占用的字节数***



**自动存储、静态存储和动态存储**

- 在函数内部定义的常规变量使用自动存储空间，被称作**自动变量**。
- 静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：
  - 在函数外面定义
  - 在声明变量时使用关键字static
- new和delete提供了一种比自动变量和静态变量更灵活的方法，它们管理一个内存池，被称为自由存储空间或堆。数据的生命周期不完全受程序或函数的生存时间控制。



***模板类vector是动态数组的替代品，模板类array是定长数组的替代品***



***基于范围的for循环***

对数组（或容器类，如vector和array）的每个元素执行相同的操作：



```c++
double prices[5] = {1.1,2.2,3.3,4.4,5.5};
for(double x: prices)
    cout<<x<<endl;
```



检测文件尾（EOF）结束输入

设置这个标记后，cin将不读取输入。cin.clear()方法可能清楚EOF标记，使输入继续进行。



在for循环中，continue语句使程序直接跳到更新表达式处，然后跳到测试表达式处。对于while循环中，continue将使程序直接跳转到测试表达式处，因此while循环体中位于continue之后的更新表达式都将被跳过。



当用户输入与变量类型不匹配，程序将不再读取输入。如若想要继续读取，则需要重置cin以接收新的输入，进而删除错误输入，并提示用户再输入。



```c++
int golf;
if(!(cin>>golf))
{
    cin.clear();
    while(cin.get()!='\n')
        continue;
    cout<<"Please enter a number";
}
```



***文件输出/输入需要做的准备***：  

- 必须包含头文件`fstream`
- 头文件`fstream`定义了一个用于处理输出的`ofstream`/`ifstream`类
- 需要声明一个或多个`ofstream`/`ifstream`变量，并以自己喜欢的方式对其命名
- 必须指明名称空间`std`
- 需要将`ofstream`/`ifstream`对象与文件关联起来。为此，方法之一是使用`open()`方法
- 使用完文件后，应使用方法`close()`将其关闭
- 可结合使用`ofstream`/`ifstream`对象和运算符`<<`/`>>`来输出/输入各种类型的数据



***内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存***



使用内联函数，必须采取下述措施之一：

- 在函数声明前加上关键字inline
- 在函数定义前加上关键字inline



引用接近const指针，必须在创建时进行初始化，一旦与某个变量关联起来，就一直效忠于它。



如果实参与引用参数不匹配，C++将生成临时变量（仅当参数为const引用时，C++才允许这样做）。在下面两种情况下生成临时变量：

- 实参的类型正确，但不是左值
- 实参的类型不正确，但可以转换为正确的类型



***右值引用，使用&&声明***

***左值引用，使用&声明***



**返回引用的函数，实际上是被引用的变量的别名**



**使用引用参数的主要原因有两个：**

- 能都修改调用函数中的数据对象
- 通过传递引用，可以提高程序的运行速度



**模板的显式实例化和显式具体化：**

- 显式实例化：`template void Swao<int>(int,int);`
- 显式具体化：`template <> void Swap(int &,int &);`或`template <> void Swap<int>(int &, int &);`



**C++中四种不同的存储数据方案：**

- 自动存储持续性
- 静态存储持续性
- 线程存储持续性
- 动态存储持续性



***3种静态持续变量***（所有静态持续变量在整个程序执行期间都存在）

- 外部链接性（可在其他文件中访问），在代码块的外面声明它
- 内部链接性（只能在当前文件中访问），在代码块的外面声明它，并使用static限定符
- 无链接性（只能在当前函数或代码块中访问），在代码块内声明它，并使用static限定符



**在默认情况下全局变量的链接性是外部的，但const全局变量的链接性为内部的**



**声明区域**是可以在其中进行声明的区域。

**潜在作用域**从声明点开始，到其声明区域的结尾。

变量对程序而言可见的范围被称为作用域。



C++通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会与另一个名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。



**名称空间可以是全局的，也可以位于另一个名称空间中吗，但不能位于代码块中。因此，在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）。**



未命名的名称空间。不能在未命名名称空间所属文件之外的其他文件中，使用该名称空间中的名称，这提供了链接性为内部的静态变量的替代品。



关于名称空间的一些编程理念：

- 使用在已命名的名称空间中声明的变量，而不是使用外部全局变量
- 使用在已命名的名称空间中声明的变量，而不是使用静态全局变量
- 如果开发了一个函数库或类库，将其放在一个名称空间。
- 仅将编译指令using作为一种将旧代码转化为使用名称空间的权宜之计。
- 不要在头文件中使用using编译指令。
- 导入名称时，首选使用作用域解析运算符或using声明的方法
- 对于using声明，首选将其作用域设置为局部而不是全局。









